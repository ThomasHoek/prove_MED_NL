######################## Functions #####################
[]
prelude =
    import re
    import os
    
    # file handling
    cur_path = os.getcwd()
    info = open(f"{cur_path}/config.txt", "r")
    langpro_path = info.readline().replace("langpro=","").rstrip()
    sick_path = info.readline().replace("prove_SICK_NL=","").rstrip()

    def part_to_prolog_arg(part):
        if part == 'all':
            return "[]"
        if part.isdigit():
            return part
        if part in 'trial train test'.split():
            "['{}']".format(part)
        return "['{}']".format(part)

    def part_to_med_filename(part):
        d = {'trial': 'MED_trial',
             'train': 'MED_train',
             'test':  'MED_test_annotated'
            }
        return d[part]

    #########################################
    # abduction-specific

    def flag2par(flag):
        '''Interpret acronyms of parameters.
           cN - core number, rN - rule application number,
           pMN - patterns with M terms and N terms.
        '''
        # lookup table
        mapping = {'al': 'aall',
                   'ch': 'constchk',
                   'w3': 'wn_ant, wn_sim, wn_der',
                   '-k': 'no_kb',
                   '-w': 'no_wn',
                   # rN
                   # induction parameters
                   'ab': 'align-both',
                   'an': 'align-no_align',
                   'aa': 'align-align',
                   'ch': 'constchk',
                   'cKB': 'constKB',
                   'cT': 'compTerms'
                   # pNM
                  }
        if flag in mapping:
            return mapping[flag]
        # cores or rule limit
        m = re.match('[rcpv](\d+)$', flag)
        if m:
            n = int(m.group(1))
            if flag[0] == 'r':
                return "ral({})".format(n)
            # used for injecting version for file,
            # it has no affect for proving
            elif flag[0] == 'v':
                return "v{}".format(n)
            elif flag[0] == 'c':
                if n == 1:
                    return 'true'
                return "parallel({})".format(n if n else '_')
            else: # induction parameter
                return "patterns-({})".format(expand_patterns(str(n)))
        raise ValueError('Unknown flag: {}'.format(flag))

    def flags2pars(flags):
        return ', '.join([ flag2par(f) for f in flags.split(',') ])

    def expand_patterns(pat):
        mappings = {'1': '_',
                    '2': '_@_',
                    '3': '(_@_)@_, _@(_@_)',
                    '4': '_@(_@(_@_)), _@((_@_)@_), (_@_)@(_@_), ((_@_)@_)@_, (_@(_@_))@_'
                    }
        patterns = ','.join([ mappings[p] for p in pat ])
        return "[{}]".format(patterns)

    def TDE2prologList(p):
        d = {'T': 'train',
             'D': 'trial',
             'E': 'test'
            }
        if p in d:
            return "[{}]".format(d[p])
        else:
            return "[{}]".format(','.join([ d[c] for c in p ]))


# Test if files paths are correct [debugging]
[sicktest_path]
deps = %{sick_path}
recipe =
    touch %{sick_path}/test.txt

[langpro_path]
deps = %{langpro}
recipe =
    touch %{langpro}/test.txt

#########################################################
# Prerequisite fixing
#########################################################

[fix_aethel]
recipe = 
    sed -i -e "s/return f'v(X{index},{type_to_natlog(_type)}'/return f'v(X{index},{type_to_natlog(_type)})'/g" aethel/scripts/langpro_interface.py
    sed -i -e "s/return f'(abst({term_to_natlog(var)},{term_to_natlog(body)}))'/return f'abst({term_to_natlog(var)},{term_to_natlog(body)})'/g" aethel/scripts/langpro_interface.py

#########################################################
# Annotations and Annotated simply-typed Terms
#########################################################

# json files needs to be produced separately, not as part of other rules,
# because it takes time to create them and this avoid their accidental creation
[MED_NL/anno/spacy_%{size}.json]
cond = %{ size in ('sm', 'md', 'lg') }
dep.sick = %{sick_path}
dep.raw = MED_NL/raw.spl
dep.py = %{sick}/python/spacy_lex_anno.py
recipe =
    python3 %{py} -s %{size} %{raw} %{target}

# lazy
[HELP_NL/anno/alpino.json]
dep.sick = %{sick_path}
dep.alpino_xml_dir = HELP_NL/parses/xml_help
dep.py = %{sick}/python/alpino_anno.py
recipe =
    python3 %{py} %{alpino_xml_dir} %{target}

[MED_NL/anno/alpino.json]
dep.sick = %{sick_path}
dep.alpino_xml_dir = MED_NL/parses/alpino_xml
dep.py = %{sick}/python/alpino_anno.py
recipe =
    python3 %{py} %{alpino_xml_dir} %{target}

# old rule. now LangPro puts trees and lex anno on the fly
#[MED_NL/anno_terms/%{parser}.%{anno}.pl]
#dep.anno = MED_NL/anno/%{anno}.json
#dep.parser = MED_NL/parses/%{parser}.pl
#dep.sen = MED_NL/sen.pl
#dep.prolog = prolog/tlg_to_tt.pl
#recipe =
#    swipl -g "write_anno_tts('%{target}', '%{anno}'), halt" -f %{prolog} %{parser} %{sen}

[HELP_NL/parses/%{parser}.pl]
cond = %{ parser in ('alpino_aethel') }
dep.sick = %{sick_path}
dep.py = %{sick}/python/alpino_terms.py
dep.xml = HELP_NL/parses/xml_help
recipe = 
    # needs python 3.10 due to aethel convertor
    python3.10 %{py} %{xml} > %{target}
 
[MED_NL/parses/%{parser}.pl]
cond = %{ parser in ('alpino_aethel') }
dep.sick = %{sick_path}
dep.py = %{sick}/python/alpino_terms.py
dep.xml = MED_NL/parses/alpino_xml
recipe = 
    # needs python 3.10 due to aethel convertor
    python3.10 %{py} %{xml} > %{target}



[langpro_MED]
dep.sick = %{sick_path}
recipe = 
    swipl -f %{sick}/prolog/main.pl  MED_NL/sen.pl  MED_NL/parses/alpino_aethel.pl  %{sick}/WNProlog/wn.pl


[langpro_HELP]
dep.sick = %{sick_path}
recipe = 
    swipl -f %{sick}/prolog/main.pl  HELP_NL/sen.pl  HELP_NL/parses/alpino_aethel.pl  %{sick}/WNProlog/wn.pl

[langpro_HELP_X]
dep.sick = %{sick_path}
dep.main = %{sick}/prolog/main.pl
dep.parser_pl = HELP_NL/parses/alpino_aethel.pl
dep.sen = HELP_NL/sen.pl
dep.wn = %{sick}/WNProlog/wn.pl
anno_json = HELP_NL/anno/alpino.json
answer = Results/HELP/results.ans
log = Results/HELP/results.log
recipe = 
    mkdir -p Results/HELP/
    (time swipl -g "parList([parts([HELP]), lang(nl), aall, wn_ant, wn_sim, wn_der, constchck, allInt, anno_json('%{anno_json}'), waif('%{answer}')]), entail_some(3000-3519)" -f %{main}  %{parser_pl} %{sen} %{wn}) > %{log} 2>&1


[langpro_HELP_P]
dep.sick = %{sick_path}
dep.main = %{sick}/prolog/main.pl
dep.parser_pl = HELP_NL/parses/alpino_aethel.pl
dep.sen = HELP_NL/sen.pl
dep.wn = %{sick}/WNProlog/wn.pl
anno_json = HELP_NL/anno/alpino.json
answer = Results/HELP/results.ans
log = Results/HELP/results.log
recipe = 
    mkdir -p Results/HELP/
    (time swipl -g "parList([parts([HELP]), lang(nl), parallel(_), aall, wn_ant, wn_sim, wn_der, constchck, allInt, anno_json('%{anno_json}'), waif('%{answer}')]), entail_all, halt" -f %{main}  %{parser_pl} %{sen} %{wn}) > %{log} 2>&1


[Results/%{part}/%{parser}.%{anno}.ans]
cond = %{ part in 'paper crowd'.split() and parser in 'alpino_aethel'.split() and anno in ('spacy_lg','alpino') }
dep.sick = %{sick_path}
dep.main = %{sick}/prolog/main.pl
dep.sen = MED_NL/sen.pl
dep.parser_pl = MED_NL/parses/%{parser}.pl
anno_json = MED_NL/anno/%{anno}.json
dep.wn = %{sick}/WNProlog/wn.pl
log = Results/%{part}/%{parser}.%{anno}.log
med_part = %{ "parts(['{}'])".format(part) }
recipe =
    mkdir -p Results/%{part}/
    ( time swipl -g "parList([%{med_part}, lang(nl), parallel(_), aall, wn_ant, wn_sim, wn_der, constchck, allInt, anno_json('%{anno_json}'), waif('%{target}')]), entail_all, halt" -f %{main}  %{parser_pl} %{sen} %{wn} ) > %{log} 2>&1

# other produce commands yet to be converted 
# [will be converted when required]
